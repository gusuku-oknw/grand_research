# pHash 一致マスク画像と逆DCTの仕組み（論文用メモ）

## 1. 何をしているか
- 32×32 に縮小した画像の DCT を取り、左上 8×8 の低周波ブロックから pHash（符号パターン）を作る。
- マスク画像では、この低周波ブロックの **符号だけを元画像と一致** させ、高周波は **ランダムノイズ** に置き換える。
- 逆DCTをかけることで、pHash は元と一致しつつ、見た目はノイズ（元情報が判別不能）な画像が得られる。
- これを低閾値シークレット S1、本物画像を高閾値シークレット S2 とし、Shamir の階層型で k1→S1, k2→S2 を復元する。

## 2. 逆DCTのイメージ
- DCT: 画像を周波数成分に分解し、左上が「ぼんやり情報」（低周波）、右下が「細かい情報」（高周波）。
- マスク生成でやっていること：
  1. 元画像の低周波 8×8 符号（pHash 核）を取得。
  2. その符号に従って低周波係数を +/− で設定（振幅はランダム）。
  3. 高周波係数は PRG からのノイズで埋める。
  4. 逆DCT→空間画像に戻すと、「pHash は一致」かつ「見た目はノイズ」になる。

## 3. 漏洩リスクと対策（論文で書くべきポイント）
- **生成時の平文扱い**: マスク生成はクライアントでのみ実施し、処理後はメモリをクリア。必要に応じて TEE/SGX などで隔離。
- **視覚的リーク**: 高周波ノイズと低周波振幅を強め、SSIM/LPIPS/認識器で「元が特定できない」ことを定量評価。
- **pHash の情報漏洩**: pHash は低周波64bitを含むため、HMAC/OPRF でトークン化する、距離計算を MPC/TEE に載せる、などで保護する方針を明記。
- **share の保護**: Shamir share を JSON/画像にしても、通信路・保存先は暗号化（TLS + AES-GCM 等）、アクセス制御を徹底。
- **復元環境の信頼性**: k1/k2 の復元を実行する環境を限定し、ログ/監査、TEE/MPC を検討。

## 4. この手法の位置づけ
- 主タスク: `phash_masked_sis`（k1 で pHash 一致マスク、k2 で本物）を用いたマルチシークレット SIS。
- 比較対象: plain / AES-GCM / MinHash+LSH / 従来 SIS / dealer-free / MPC をオプションとして評価。

## 5. 簡易アルゴリズム（擬似コード）
```
1) 入力画像 I を 32×32 グレースケールに縮小
2) DCT → 低周波 8×8 から符号パターン h を得る
3) マスク用 DCT 係数を構成
   - lowfreq[i] = +α / -α (h に合わせる; α はランダム振幅)
   - highfreq = ノイズ
4) 逆DCT → 32×32 画像 → 元サイズに拡大 → マスク画像 J
   => pHash(J) ≈ pHash(I), ただし視覚的にはノイズ
5) S1 = J（または J を生成する低周波 + seed）、S2 = I を Shamir で分割
   - k1 share で S1（マスク）、k2 share で S1+S2（本物）
   - k1 未満は復元不可（ノイズ扱い）
```

## 6. 実験時の見やすさ
- MSE と pHash 距離を別々の棒グラフに分ける（`stats_mse.png`, `stats_phash.png`）。
- pHash 距離は「近いほど 0 に近い」、MSE は「大きいほど離れている」と凡例やタイトルで明示。
- ノイズとの距離も入れて、dummy と明確に差が出るようパラメータ（α, highfreq_scale, リトライ回数）を調整する。
